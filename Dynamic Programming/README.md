# Dynamic Programming

## What is Dynamic Programming?
Dynamic Programming is a problem solving technique that is used in **optimization** of a problem that has overlapping sub-problems and optimal substructure properties.

Dynamic Programming is one of the hardest and most diverse programming topic. The most important concept of Dynamic Programming will be understanding the idea of how to solve that problem, and how to optimize the process by removing the repeated steps.

## What is the difference between Greedy and Dynamic Programming?
They are both used for **optimization**. However, they have different strategies.
* Greedy
  * Follow the predefined optimized procedure/decision, in order to have the optimized result.
  * It making the choices in a serial forward fashion, never looking back or revising previous choices.
  * For Example: **Dijkstra Algorithm**
    * It always select the least weighted path to get the shortest path.
* Dynamic Programming
  * Find out all possible solutions and pick up the best (optimized) solution.
  * It computes by synthesizing them from smaller subsolutions, and by trying many possibilities and choices before it reaches optimization.
  * It is usually solved by recursive formulas (does not mean recursion).
  * It follows **Principle of Optimality**.

## Principle of Optimality
A problem is said to satisfy the Principle of Optimality if the subsolutions of an optimal solution of the problem are themesleves optimal solutions for their subproblems.
* Examples:
  * The shortest path problem satisfies the Principle of Optimality.
  * This is because if a,x1,x2,...,xn,b is a shortest path from node a to node b in a graph, then the portion of xi to xj on that path is a shortest path from xi to xj.
  * The longest path problem, on the other hand, does not satisfy the Principle of Optimality. Take for example the undirected graph G of nodes a, b, c, d, and e, and edges (a,b) (b,c) (c,d) (d,e) and (e,a). That is, G is a ring. The longest (noncyclic) path from a to d to a,b,c,d. The sub-path from b to c on that path is simply the edge b,c. But that is not the longest path from b to c. Rather, b,a,e,d,c is the longest path. Thus, the subpath on a longest path is not necessarily a longest path.

## Memoization
This method will store the results of the function, which avoiding the same call of the recursive process.
For Example:
```cpp
int fib(int n){
  if(n <= 1>){
    return n;
  }
  return fib(n-2) + fib(n-1);
}
```
Originally, this function will take Time Complexity of **O(2^n)**. However, it can further reduces to **O(n)** by memoization.
* By marking the result of all result from fib(0) to fib(n), the repeated process can be processed in O(1)
  * For Example: storing all the results to a array of size n.

## Tabulation
A table will be generated by the function. It runs iterative function mostly which fill up the table to get the values
The difference between the recursion example above is top-down (n to 0) and Iteration is bottom-up (0 to n)
